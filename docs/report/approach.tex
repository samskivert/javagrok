\section{Technical Approach}
To infer information about Java code we use existing inference tools and
combine their output. We have additionally developed a simple framework to aid
in writing our own analyses.

To combine the results of disparate analyses we have to convert their results
into a common format at some point in our toolchain.  We will use the JAIF
(Java Annotation Index File) format for that purpose.  Some anaylses generate
results directly in JAIF format, some provide annotated bytecodes which can be
easily extracted into JAIF format, and others provide textual results for which
we will read the results into a our framework.

\begin{figure}
\centering
\psfig{file=figures/technicalApproach/technicalApproach.eps, width=3in}
\caption{Toolchain}
\label{fig:toolchain}
\end{figure}

In the following section we describe our analysis framework and how we
integrate all the tools into JavaGrok (also see Figure~\ref{fig:toolchain} 
which illustrates the stages in our toolchain explained below).

First we let Uno run over the source code which we want to annotate. 
Because Uno infers properties which get stored in a single separate file, 
we changed UNO's output format slightly. 
To integrate the analysis results into the Java documentation we
use our own framework. We implemented a tree visitor inside the Java 7 
compiler that, at initialization, reads in the file generated by UNO and 
stores the information in a hashset. During the iteration over the AST
our visitor inserts annotation at the appropriate places. These then
get extracted into files in the JAIF format.

To infer exception annoation we use the Annotation Processing Tool (APT)
API~\cite{apt} built into the Java standard compiler.  From within an APT plugin
we can access the compiler's abstract syntax tree and augment the generated
bytecode with annotations representing our analysis results. These annotations
are then extracted into external annotation files.

Javarifier produces its results directly in the JAIF format which allows us to
easily integrate it into our toolchain. We need simply to express the meaning
of its inferred constraints in the Javadoc documentation in concise language.

Once the results of the various analyses have been collected into a set of
annotation files, we use the annotation file utilities~\cite{AFU} to merge
those annotations back into the original library source. Of course this source
can now be used either directly by looking at the annotated source code. But
we also let javadoc run over the source code to generate html documentation
which now include our annotations.
