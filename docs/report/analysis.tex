\section{Analyses}

In this section we describe the analyses we perform: their implementation,
output, and why each analysis would be useful for a developer.

% \subsection{Javarifier}
% \label{sec:Javarifier}

% Javarifier is a tool to infer reference immutability information built in
% conjuction with research done by Quinonez et al.~\cite{Javarifier}. It infers
% mutability constraints for object fields, method arguments and receivers.  We
% use \textit{mutate} to mean updating the value of an object's fields, calling a
% method on an object that updates the values of its fields, or calling a method
% on an object that mutates an object referenced by one of its fields.

% Below we enumerate the annotations inferred by Javarifier which are utilized by
% JavaGrok, and a summary of what they communicate to the developer:

% \texttt{@ReadOnly} When appearing on a method, this indicates to the developer
% that the method will not mutate its receiver. When appearing on a method
% argument, this indicates to the developer that the method will not mutate the
% argument through the supplied reference.

% \texttt{@Mutable} When appearing on a method, this indicates to the developer
% that the method may mutate its receiver. When appearing on a method argument,
% this indicates to the developer that the method may mutate the argument through
% the supplied reference.

% Javarifier generates two additional annotations which are important for type
% checking, but not important when simply communicating method behavior to a
% developer.

% \texttt{@QReadOnly} appears on type parameters of method arguments, for example
% \texttt{List<@QReadOnly Date>}. Such an annotation on a method argument
% indicates that the method accepts both \texttt{List<@ReadOnly Date>} and
% \texttt{List<@Mutable Date>}. However, the method itself is restricted to only
% operations allowed on both read-only and mutable dates, which is strictly a
% subset of the operations allowed on read-only dates.

% \texttt{@PolyRead} indicates that a method and/or its arguments are polymorphic
% over mutability. Such a method may legally be instantiated with
% \texttt{@ReadOnly} receiver and/or arguments and thus must not mutate the
% receiver or arguments.

% We convert both of the above annotations to \texttt{@ReadOnly}, as
% that is sufficient to communicate the method's behavior to the developer and we
% are not concerned with type-checking mutability.

\subsection{Uno}

Uno~\cite{Uno} infers alias and encapsulation properties as well as a a number
of other properties. We selected some of these which we regarded useful for our
purposes based on our own experience. The chosen properties 
provide information about how a certain function treats its parameters, return 
values and fields when called. More concretely, it infers whether or not a 
function captures or leaks a reference, or returns a new unique reference.

Below we enumarete the annotations we infer.

\texttt{@UniqueReturn} on method declarations. This annotations indicates 
that the return value is a unique reference to its referent.
\texttt{@NonUniqueReturn} can occur on method declarations and means that 
there is at least one possible path between method entrance and exit in
which the returned reference is not the only reference to its referent.
\texttt{@Retained} when appearing in front of a method parameter it indicates
that the're exists at least one path between method entrance and exit in 
which the reference get's captured. For example might the called method store
a reference to the referent in a local field.
\texttt{@NotRetained} respectively indicates that the method has no execution 
paths which retains a reference to the passed object.

Our hypothesis is that the retention annotations is useful to developers
because it tells at a simple glance at the method interface if the argument
one passes is possibly gonna be retained. If so, the developer can either only
pass a copy of the object as an argument or is at least aware that the uniqueness
of the object's reference might not be maintained by that method.

\subsection{Thrown Exceptions}

Java requires that checked exceptions be declared by methods that raise them,
but frequently the conditions under which exceptions are raised are unclear to a
library user. Even with checked exceptions, often a supertype of a thrown
exception is declared.  While knowing that an \texttt{IOException} might be
thrown is useful, knowing that the method might throw either a
\texttt{FileNotFoundException} or \texttt{InterruptedByTimeoutException} is more
useful to a developer, because knowing the specific exception may help to debug
a program; knowing that a \texttt{FileNotFoundException} was thrown tells a
developer to check that file paths are correct and that any tasks that should
have created the file ran correctly, while an \texttt{IOException} could
indicate a variety of problems with local files, or any of a number of problems
with the network.  Additionally, unchecked exceptions need not be declared in Java method
signatures or documentation and can remain entirely invisible to the library
user until they are encountered at runtime.

To alleviate this, we infer some of the conditions under which a method would
throw an exception, and produce annotations of the form:

\begin{verbatim}
@Throws(when =
    "IllegalArgumentException when (x < 0)")
public Object getElement(int x) { ... }
\end{verbatim}

This inferred information can inform developers of unchecked exceptions,
and alert them to otherwise undocumented assumptions of a library without
requiring developers to dig through the library's code.
Annotations may contain a list of exceptions and conditions, and for some
complex conditions we reduce the condition to ``sometimes'' because our analysis
performs no symbolic execution.  We do not use an
existing analysis tool because none were available for this task, but our
simple analysis provides adequate results.  Implementation details are presented
in Section \ref{sec:exception_impl}.

As in Buse and Weimer's work on inferring exceptional conditions for
documentation~\cite{autodoc}, we expose internal field names and
local variable names in exceptional conditions.  We agree with their assessment
that while this leaks some
implementation information and is not necessarily informative, in practice
leaked variables are often still useful: for example, showing that an exception is
thrown from a list's \texttt{remove()} method when a local variable \texttt{len}
is equal to 0 has clear implications.

\subsection{Nullability}
\label{sec:Nullability}

In heavily object oriented languages like Java, every variable is nullable,
capable of holding either a reference or the
special value null.  Because of this ubiquity, one common mistake is to call
methods with null parameters they are unprepared to handle, or to erroneously
assume that returned values are never null.  Well documented libraries, like
the Java collections framework, frequently spell out when variables are
assumed to be nullable or not-null, while many libraries with weaker
documentation omit this information entirely.

By means of a nullability type inference~\cite{NonNullTypeInference} we can add
similarly useful information to documentation.  Although the JastAdd analysis
we've chosen to use does not require a whole program, it does make a closed
world assumption; that is, it assumes it is analyzing all code that will ever be
linked with the library.  This leads to optimistic annotation inferences when run on
library code.  JastAdd produces \texttt{@NonNull} annotations, indicating that the user should assume that an
argument or method return value will not assume the value \texttt{null}.
