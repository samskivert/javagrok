\section{Analysis}

In this section we describe the analyses we perform: their implementation,
output, and why each analysis would be useful for a developer.

\subsection{Javarifier}
\label{sec:Javarifier}

Javarifier is a tool to infer reference immutability information built in
conjuction with research done by Quinonez et al.~\cite{Javarifier}. It infers
mutability constraints for object fields, method arguments and receivers. Those
constraints may be \texttt{mutable}, \texttt{readonly}, \texttt{?~readonly},
\texttt{polyread}, and \texttt{this-mutable}. The \texttt{?~readonly}
constraint indicates a method argument with a \texttt{readonly} upper bound and
a \texttt{mutable} lower bound. The \texttt{polyread} constraint provides
polymorphism over mutability for method arguments and receivers
(i.e. indicating that a method is read-only when called through a read-only
reference or mutable when called through a mutable reference). A
\texttt{this-mutable} reference provides similar polymorphism for object
fields: a \texttt{this-mutable} field is mutable if \texttt{this} is mutable
and read-only otherwise.

Javarifier produces its results directly in the JAIF format which allows us to
easily integrate it into our toolchain. We need simply to express the meaning
of its inferred constraints in the Javadoc documentation in concise language.

\subsection{Uno}

Uno is an open source tool which is the outcome of research done by Ma and
Foster~\cite{Uno}. It infers alias and encapsulation properties for Java.  The
tool generates annotations which provide information about how a certain
function treats its parameters, return values and fields (in the case of a
non-static function) when called. E.g. if a function captures or leaks a
reference or returns a new unique reference.

The tool generates annotations which are stored in a single separate file. 
To integrate the analysis results of UNO into the Java documentation we
use our own framework. We implemented a tree visitor inside the Java 7 
compiler that, at initialization, reads in the file generated by UNO and 
stores the information in a hashset. During the iteration over the AST
our visitor inserts annotation at the appropriate places.

\subsection{Thrown Exceptions}

Java requires that checked exceptions be declared by methods that raise them,
but it unfortunately cannot require that they be well documented, and
frequently the conditions under which exceptions are raised are unclear to a
library user. Even with checked exceptions, often a supertype of a thrown
exception is declared.  While knowing that an \texttt{IOException} might be
thrown is useful, knowing that the method might throw either a
\texttt{FileNotFoundException} or \texttt{InterruptedByTimeoutException} is more
useful to a developer, because knowing the specific exception may help to debug
a program.  Additionally, unchecked exceptions need not be declared in Java method
signatures or documentation and can remain entirely invisible to the library
user until they are encountered at runtime.

To alleviate this, we infer some of the conditions under which a method would
throw an exception, and produce annotations of the form:

\begin{verbatim}
@ExceptionProperty(throwsWhen =
    "{IllegalArgumentException} when (x < 0)")
public Object getElement(int x) { ... }
\end{verbatim}

This sort of inferred information can inform developers of unchecked exceptions,
and alert them to otherwise undocumented assumptions of a library without
requiring developers to dig through the library's code.
Annotations may contain a list of exceptions and conditions, and for some
complex conditions we reduce the condition to ``sometimes'' because our analysis
is purely syntactic.  We do not use an
existing analysis tool because none were available for this task, but even our
syntactic analysis provides useful results.

Our analysis is a fairly simple search for explicit throws, tracking branch
statements at the purely syntactic level on the
way to such statements.  We propagate information about exceptional conditions
between methods by purely syntactic replacement of formal arguments by actual
arguments.  We do not account for intermediate side effects on variables, or
track data flow from arguments to local variables or object fields.  In
practice, we have not found this lack of precision to be problematic as most of
the thrown exceptions we see are from argument validation.

Buse and Weimer infer documentation for exception conditions
using an analysis performs that some symbolic execution along paths to reach throw
statements, propagating information between methods as necessary~\cite{autodoc}.
Because they
perform full symbolic execution, their tool can be much more precise than ours.
Replacing our exception analysis with theirs, or implementing our own symbolic
execution would likely improve the quality of our exception documentation.  

As in Buse and Weimer's work, we expose internal field names and
local variable names in exceptional conditions.  We agree with their assessment
that while this leaks some
implementation information and is not necessarily informative, in practice
leaked variables are still useful: for example, showing that an exception is
thrown from a list's \texttt{remove()} method when a local variable \texttt{len}
is equal to 0 has clear implications.

\subsection{Nullability}
\label{sec:Nullability}

In heavily object oriented languages like java, every variable is nullable
(aka. option, maybe), capable of holding either a reference to a value or the
special value null.  Because of this ubiquity, one common mistake is to call
methods with null parameters they are unprepared to handle, or to erroneously
assume that returned values are never null.  Well documented libraries, like
the Java collections framework, will frequently spell out when variables are
assumed to be nullable or not-null when an ambiguity seems likely.

By means of a nullability inference~\cite{NIT,NonNullTypeInference} we can add
similarly useful type decorations to documentation.  Although two Java
nullability inferences are freely available, they are both whole program
analyses and therefore ill-suited to our target application: library
documentation.  We plan to first try adapting their existing analysis code, or
failing that re-implement a modular version of their analysis within our own
framework.

